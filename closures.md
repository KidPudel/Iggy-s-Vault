Closures are (closing a function and handling it's results further) nester or [[inner function]] that is generated by enclosing/outer function and get's *returned itself by the enclosing function*

Closure function has an access to the enclosing function's data, *even after outer function finished* execution. This is possible, because the *closure keeps the reference to its own enclosing scope*. so if we change data in closure by using [[scoping variables keywords]] like `nonlocal`, it is changed in that reference scope as well

- Closures **allows keeping outer data private (including inner functions) and not make this data global**, since closure has an access to the outer function
- Allows as to return a  [[callback]], which allows as to return a whole functionality with any data we want, since we return a function
- Allow as to implement a [[decorator]] function

```python
def store_message(message: str):
    outer_message = message
    def change_message(new_message: str):
        nonlocal outer_message
        print(outer_message)
        outer_message = new_message
        return outer_message
    
    return change_message
    
change = store_message("message")

print(change("new message"))
print(change("new message again"))

# message
# new message
# new message
# new message again
```


# [[decorator]] example

[[args and kwargs]]


[[decorator]]

```python
def comment_on_function(decorated_function):
    def wrapper(*args, **kwargs):
        nonlocal decorated_function
        result = decorated_function(*args, **kwargs)
        print("your function " + decorated_function.__name__ + " returns: " + str(result))

        return result
    # return a nested function to return/ trigger with functionality 
    return wrapper

@comment_on_function
def add_two(x: int, y: int) -> int:
    return x + y

if __name__ == "__main__":
    print(add_two(5, 2))

# your function add_two returns: 7
# 7
```
